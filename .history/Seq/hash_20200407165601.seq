from globals import *


class Hash:
    Status: str
    hash: int

    def __init__(self: Hash, hash: int, status: str):
        self.hash = hash
        self.status = status

class Minimizer:
	hash: Hash
	loc: int
    def __init__(self: Minizer, hash: Hash, loc: int):
        self.hash = hash
        self.loc = loc
class Sequence:
	name: str
	seq: str
	is_rc: bool

	def __init__(self: Sequence, name: str, seq: str, is_rc: bool):
        self.name = name
        self.seq = seq
        self.is_rc = is_rc


class Index:
	kmer_size: int 
	window_size: int
	threshold: int

	Sequence seq

	minimizers: list[Minimizer]
    index: dict[Hash, list[int]]

	def __init__(self:Index,seq: Sequence, kmer_size: int, window_size: int, separate_lowercase: bool):
        self.seq = seq
        self.kmer_size = kmer_size
        self.window_size = window_size

        assert(kmer_size <= 16)
        minimizers = get_minimizers(seq, kmer_size, window_size, separate_lowercase)

        for i in minimizers:
            index.setdefault(i.hash,list[int]()).append(i.loc)
        h = Hash()
        ignore = (minimizers.size() * h.INDEX_CUTOFF) / 100.0
        dict[int,int] hist
        for i in index:
            hist[i.second.size()] += 1
        sum = 0
	    self.threshold = 1 << 31
        j = 0
        for i in hist.keys():
            sum += hist[i]
            if sum <= ignore:
                threshold = i
            else:
                break
            



	# Find first minimizer at loci p
	# def find_minimizers(p:int):



vector<Minimizer> get_minimizers(const string &s, int kmer_size, 
	const int window_size, bool separate_lowercase)
{
	vector<Minimizer> minimizers;
	minimizers.reserve((2 * s.size()) / window_size);
	deque<Minimizer> window;

	const uint32_t MASK  = (1 << (2 * kmer_size)) - 1;
	uint32_t h = 0;
	int last_n = - kmer_size - window_size;
	int last_u = last_n;
	for (int i = 0; i < s.size(); i++) {
		if (toupper(s[i]) == 'N') {
			last_n = i;
		} else if (isupper(s[i])) {
			last_u = i;
		}

		h = ((h << 2) | hash_dna(s[i])) & MASK; 

		if (i < kmer_size - 1) 
			continue;

		Hash hh { h, last_n >= (i - kmer_size + 1) 
			? Hash::Status::HAS_N 
			: (last_u >= (i - kmer_size + 1))
				? Hash::Status::HAS_UPPERCASE 
				: Hash::Status::ALL_LOWERCASE
		};   
		if (!separate_lowercase && hh.status == Hash::Status::ALL_LOWERCASE) {
			hh.status = Hash::Status::HAS_UPPERCASE;
		}
		while (!window.empty() && !(window.back().hash < hh)) {
			window.pop_back();
		}
		while (!window.empty() && window.back().loc < (i - kmer_size + 1) - window_size) {
			window.pop_front();
		}
		window.push_back({hh, i - kmer_size + 1});

		if (i - kmer_size + 1 < window_size) 
			continue;
		if (!minimizers.size() || !(window.front() == minimizers.back())) {
			minimizers.push_back(window.front());
		}
	}
	return minimizers;
}
