from align_hit import *
from Tree import *
from hash import *
from sliding import *
from globals import*
from common import *
from extendedFunctions import *
from test2 import *
# import function
def is_overlap(tree:Tree,pf_pos,pf_end, pfp_pos,pfp_end) -> bool:
	assert(pf_pos <= pf_end)
	assert(pfp_pos <= pfp_end)
	i1  = set(Interval(pf_pos,pf_end) + Interval(pfp_pos,pfp_end))
	# for it in i1:
	#     sA = 
	if len(i1) > 0:
		return True
	return False

def parse_hits(hits):
	#: list[Hit]
	hits_real = list[Hit]()
	for h in hits:
		add = True
		for ph in hits:
			if(h  != ph ):
				if (h.ref_start >= ph.ref_start and h.ref_end <= ph.ref_end and h.query_start >= ph.query_start and h.query_end <= ph.query_end):
					add = False
					break
		if (add):
			hits_real.append(h)
	return hits_real

def extend1(winnow: SlidingMap, query_hash: Index, query_start,  query_end,  query_winnow_start,  query_winnow_end,ref_hash: Index,  ref_start,  ref_end,  ref_winnow_start,  ref_winnow_end, same_genome) -> Hit:
	assert(query_start < len(query_hash.seq.seq))
	# return Hit()
	assert(ref_start < len(ref_hash.seq.seq))
	assert(query_end <= len(query_hash.seq.seq))
	assert(ref_end <= len(ref_hash.seq.seq))

	# extensions = list[function()]
	extensions = list[tuple[function[bool,SlidingMap, Index, int,  int,  int,  int,Index,  int,  int,  int,  int, bool],function[bool,SlidingMap, Index, int,  int,  int,  int,Index,  int,  int,  int,  int, bool] ]]()
	extensions.append(do_extend_both_both,undo_extend_both_both)
	extensions.append(do_extend_both_right,undo_extend_both_right)
	extensions.append(do_extend_both_left,undo_extend_both_left)

	# first extend to the boundaries:
	query_start =  query_hash.minimizers[query_winnow_start - 1].loc + 1 if query_winnow_start else 0
	query_end = query_hash.minimizers[query_winnow_end].loc if query_winnow_end < len(query_hash.minimizers) else len(query_hash.seq.seq)
	ref_start = ref_hash.minimizers[ref_winnow_start - 1].loc + 1 if ref_winnow_start else 0
	ref_end = ref_hash.minimizers[ref_winnow_end].loc  if ref_winnow_end < len(ref_hash.minimizers) else len(ref_hash.seq.seq)

	s = Search()
	MAX_GAP_ERROR = s.MAX_ERROR - s.MAX_EDIT_ERROR

	while( True ):
		max_match = min(s.MAX_SD_SIZE, int((1.0 / MAX_GAP_ERROR + .5) * abs(query_start - ref_start)) if same_genome else s.MAX_SD_SIZE)
		aln_len = max(query_end - query_start, ref_end - ref_start)
		seq_len = min(query_end - query_start, ref_end - ref_start)
		if (aln_len > max_match or pct(seq_len, aln_len) < 100 * (1 - 2 * MAX_GAP_ERROR)):
			break
		if (same_genome):
			overlap = query_end - ref_start
			if (overlap > 0 and pct(overlap, ref_end - ref_start) > 100 * s.MAX_ERROR):
				break
		extended = False
		for fn in extensions:
			if (not fn[0](winnow, query_hash, query_start,  query_end,  query_winnow_start,  query_winnow_end,ref_hash,  ref_start,  ref_end,  ref_winnow_start,  ref_winnow_end, same_genome)):
				continue
			if (winnow.jaccard() >= 0):
				extended = True
				break
			else:
				fn[1](winnow, query_hash, query_start,  query_end,  query_winnow_start,  query_winnow_end,ref_hash,  ref_start,  ref_end,  ref_winnow_start,  ref_winnow_end, same_genome)
		if (not extended):
			break
	return Hit(query_hash.seq, query_start, query_end, ref_hash.seq, ref_start, ref_end, winnow.jaccard(), "", "OK", "")


	
	

	
	
	

def search_in_reference_interval( query_start: int, query_winnow_start:int,  query_winnow_end:int, query_hash: Index,  ref_hash: Index,tree: Tree, same_genome: bool,  init_len: int,  allow_extend: bool,  report_fails:bool, winnow: SlidingMap,  t_start: int,  t_end: int) ->list[Hit]:
	assert(t_start <= t_end)
	assert(t_start >= 0)
	assert(winnow.query_size > 0)
	TOTAL_ATTEMPTED = 0
	JACCARD_FAILED = 0
	INTERVAL_FAILED=0
	TOTAL_ATTEMPTED+=1

	ref_start = t_start
	ref_end = min(t_start + init_len, len(ref_hash.seq.seq)) # winnow is W(query) ; extend it to W(query) | W(ref)
	ref_winnow_start = ref_hash.find_minimizers(ref_start)
	assert(ref_winnow_start < len(ref_hash.minimizers))
	ref_winnow_end = ref_winnow_start
	while (ref_winnow_end < len(ref_hash.minimizers) and ref_hash.minimizers[ref_winnow_end].loc < ref_end):
		winnow.add_to_reference(ref_hash.minimizers[ref_winnow_end].hash)
		ref_winnow_end+=1
	# this part (next while loop) can be optimized
	# Roll until we find best inital match

	best_winnow = SlidingMap(winnow)
	best_ref_start = ref_start
	best_ref_end = ref_end

	best_ref_winnow_start = ref_winnow_start
	best_ref_winnow_end = ref_winnow_end
	while (ref_start < t_end and ref_end < len(ref_hash.seq.seq)):
		if (ref_winnow_start < len(ref_hash.minimizers) and ref_hash.minimizers[ref_winnow_start].loc < ref_start + 1) :
			winnow.remove_from_reference(ref_hash.minimizers[ref_winnow_start].hash)
			ref_winnow_start+=1
		if (ref_winnow_end < len(ref_hash.minimizers) and ref_hash.minimizers[ref_winnow_end].loc == ref_end):
			winnow.add_to_reference(ref_hash.minimizers[ref_winnow_end].hash)
			ref_winnow_end+=1
		if (winnow.jaccard() > best_winnow.jaccard()):
			best_ref_start = ref_start
			best_ref_end = ref_end
			best_ref_winnow_start = ref_winnow_start
			best_ref_winnow_end = ref_winnow_end
			best_winnow = winnow
		ref_start+=1
		ref_end+=1
		if (ref_end == len(ref_hash.seq.seq)):
			break
	
	hits = list[Hit]()
	if (best_winnow.jaccard() < 0):
		JACCARD_FAILED+=1
		if (report_fails):
			hits.append(Hit(query_hash.seq, query_start, query_start + init_len, ref_hash.seq, best_ref_start, best_ref_end, best_winnow.jaccard(),"", "")) #printing funtion used: fmt::format("jaccard: {} < {}"
	elif (allow_extend):
		if (not is_overlap(tree, query_start, query_start + init_len, best_ref_start, best_ref_end)):
			f = filter(query_hash.seq.seq, query_start, query_start + init_len, ref_hash.seq.seq, ref_start, ref_end)
			if (not f[0]):
				if (report_fails):
					hits.push_back(Hit(query_hash.seq, query_start, query_start + init_len, ref_hash.seq, ref_start, ref_end, 0, "", "" ))
			else:
				h = extend1(best_winnow,query_hash, query_start, query_start + init_len, query_winnow_start, query_winnow_end,ref_hash, best_ref_start, best_ref_end, best_ref_winnow_start, best_ref_winnow_end, same_genome)
				f = filter(query_hash.seq.seq, h.query_start, h.query_end, ref_hash.seq.seq, h.ref_start, h.ref_end)
				if (not f[0]):
					if (report_fails):
						h.comment = f[1]
						hits.append(h)
				else:
					hits.push_back(h)
					a = Interval(h.query_start, h.query_end)
					b = Interval(h.ref_start, h.ref_end)
					tree.insert1(a,b)
		else:
			INTERVAL_FAILED+=1
	else:
		f = filter(query_hash.seq.seq, query_start, query_start + init_len, ref_hash.seq.seq, best_ref_start, best_ref_end)
		if (f[0] or report_fails):
			hits.push_back(Hit(query_hash.seq, query_start, query_start + init_len,ref_hash.seq, best_ref_start, best_ref_end, best_winnow.jaccard(), "", ""))

	return hits






#qi, query_hash, ref_hash, tree, is_same_genome,Search2.MIN_READ_SIZE, True, False)

def search(query_winnow_start: int, query_hash: Index, ref_hash: Index, tree: Tree, same_genome: bool,init_len: int, allow_extend:bool, report_fails:bool) -> list[Hit]:
	
	internal = Internal()
	hashG = HashGlobal()
	
	l = list[Hit]()
	

	if (query_winnow_start >= len(query_hash.minimizers)):
		return l
	
	query_start = query_hash.minimizers[query_winnow_start].loc
	if (query_start + init_len > len(query_hash.seq.seq)):
		return l
	assert(query_hash.kmer_size == ref_hash.kmer_size)
	search1(query_winnow_start, query_hash, ref_hash, tree, same_genome,init_len, allow_extend, report_fails)
	# bug in this line of code:
	# print(query_hash.kmer_size)
	# nex = SlidingMap(1)
	# init_winnow=SlidingMap(14)#SlidingMap(query_hash.kmer_size)
	return l
	# candidates_prel = set[int]()
	# query_winnow_end = query_winnow_start
	
	# while( query_winnow_end < len(query_hash.minimizers) and query_hash.minimizers[query_winnow_end].loc - query_start <= init_len):
	# 	h = query_hash.minimizers[query_winnow_end].hash
	# 	init_winnow.add_to_query(h)
	# 	if (internal.DoUppercaseSeeds and h.status != hashG.statuses.index("HAS_UPPERCASE")):
	# 		continue
	# 	# here check corresponding ref intervals !!!
	# 	pf = tree.find(query_hash.minimizers[query_winnow_end].loc, False)
	# 	ptr = None
	# 	if h in ref_hash.index:
	# 		ptr = ref_hash.index[h]
	# 	if (not ptr or len(ptr) >= ref_hash.threshold):
	# 		continue
	# 	else:
	# 		for pos in ptr:
	# 			if (not same_genome or pos >= query_start + init_len):
	# 				if (len(pf) > 0 or len(tree.find(pos,True) ) > 0 ):
	# 					# need to check if 2 intervals correspond to one sequence (ref and query)
	# 					candidates_prel.insert(pos)
	# 	query_winnow_end+=1
	

	# if ( not init_winnow.query_size):
	# 	return  list[Hit]()
	# T = list[tuple[int,int]]()
	# candidates = list[int]()
	# for i in candidates_prel:
	# 	candidates.append(i)
	# i = 0
	# while (i <= len(candidates) - init_winnow.limit):
	# 	j = i + (init_winnow.limit - 1)
	# 	if (candidates[j] - candidates[i] <= init_len):
	# 		x = max(0, candidates[j] - init_len + 1)
	# 		y = candidates[i] + 1
	# 		if (len(T) and x < T[-1][1]):
	# 			T[-1][1] = max(T[-1][1], y)
	# 		else:
	# 			T.append({x, y})
			
		
	# 	i+=1
	# hits = list[Hit]()
	
	# for t in T:
	# 	if (same_genome):
	# 		t[0] = max(t[0], query_start + init_len)
	# 	if (t[0] > t[1]):
	# 		continue
	# 	h = search_in_reference_interval(query_start, query_winnow_start, query_winnow_end,query_hash, ref_hash, tree, same_genome, init_len,allow_extend, report_fails, init_winnow, t[0], t[1])
	# 	h = list[Hit]()
	# 	for hh in h:
	# 		hits.push_back(hh)
	# # remove the interval from tree!
	# # tree -= Interval(0, query_start - Globals::Search::MIN_READ_SIZE)
	# return parse_hits(hits)
	