from align_hit import *
from Tree import *
from hash import *
from sliding import *
from globals import*
from common import *
from extendedFunctions import *
# from test2 import *
from filter import *
# import function
def is_overlap(tree:Tree,pf_pos,pf_end, pfp_pos,pfp_end, s:Search) -> bool:
	assert(pf_pos <= pf_end)
	assert(pfp_pos <= pfp_end)
	RIGHT_ALLOWANCE = s.MIN_READ_SIZE
	final = list[tuple[Interval,Interval]]()
	pf = tree.find(pf_pos,False)
	if len(pf) == 0:
		return False
	pfp = tree.find(pfp_pos,True)
	if len(pfp) == 0:
		return False
	for queryInt in pf:
		for refInt in pfp:
			if refInt in tree.pairs[queryInt]:
				final.append((queryInt,refInt))
	for it in final:
		sA = it[0].low
		eA = it[0].high
		sB = it[1].low
		eB = it[1].high

		if (pf_pos >= sA and pf_end <= eA and pfp_pos >= sB and pfp_end <= eB):
			return True
		if (min(eA - sA, eB - sB) < s.MIN_READ_SIZE * 1.5):
			continue
		if (eA - pf_pos >= RIGHT_ALLOWANCE and eB - pfp_pos >= RIGHT_ALLOWANCE):
			return True


	return False

def parse_hits(hits):
	#: list[Hit]
	hits_real = list[Hit]()
	for h in hits:
		add = True
		for ph in hits:
			if(not h  is ph ):
				if (h.ref_start >= ph.ref_start and h.ref_end <= ph.ref_end and h.query_start >= ph.query_start and h.query_end <= ph.query_end):
					add = False
					break
		if (add):
			hits_real.append(h)
	return hits_real

def extend1(winnow: SlidingMap, query_hash: Index, query_start,  query_end,  query_winnow_start,  query_winnow_end,ref_hash: Index,  ref_start,  ref_end,  ref_winnow_start,  ref_winnow_end, same_genome,s) -> Hit:
	assert(query_start < len(query_hash.seq.seq))
	# return Hit()
	assert(ref_start < len(ref_hash.seq.seq))
	assert(query_end <= len(query_hash.seq.seq))
	assert(ref_end <= len(ref_hash.seq.seq))

	# extensions = list[function()]
	extensions = list[tuple[function[bool,SlidingMap, Index, int,  int,  int,  int,Index,  int,  int,  int,  int, bool],function[bool,SlidingMap, Index, int,  int,  int,  int,Index,  int,  int,  int,  int, bool] ] ]()
	extensions.append((do_extend_both_both, undo_extend_both_both))
	extensions.append((do_extend_both_right, undo_extend_both_right))
	extensions.append((do_extend_both_left, undo_extend_both_left))

	# first extend to the boundaries:
	query_start =  query_hash.minimizers[query_winnow_start - 1].loc + 1 if query_winnow_start else 0
	query_end = query_hash.minimizers[query_winnow_end].loc if query_winnow_end < len(query_hash.minimizers) else len(query_hash.seq.seq)
	ref_start = ref_hash.minimizers[ref_winnow_start - 1].loc + 1 if ref_winnow_start else 0
	ref_end = ref_hash.minimizers[ref_winnow_end].loc  if ref_winnow_end < len(ref_hash.minimizers) else len(ref_hash.seq.seq)

	MAX_GAP_ERROR = s.MAX_ERROR - s.MAX_EDIT_ERROR

	while( True ):
		max_match = min(s.MAX_SD_SIZE, int((1.0 / MAX_GAP_ERROR + .5) * abs(query_start - ref_start)) if same_genome else s.MAX_SD_SIZE)
		aln_len = max(query_end - query_start, ref_end - ref_start)
		seq_len = min(query_end - query_start, ref_end - ref_start)
		if (aln_len > max_match or pct(float(seq_len), float(aln_len)) < 100 * (1 - 2 * MAX_GAP_ERROR)):
			break
		if (same_genome):
			overlap = query_end - ref_start
			if (overlap > 0 and pct(float(overlap), float(ref_end - ref_start)) > 100 * s.MAX_ERROR):
				break
		extended = False
		for fn in extensions:
			if (not fn[0](winnow, query_hash, query_start,  query_end,  query_winnow_start,  query_winnow_end,ref_hash,  ref_start,  ref_end,  ref_winnow_start,  ref_winnow_end, same_genome)):
				continue
			if (winnow.jaccard() >= 0):
				extended = True
				break
			else:
				fn[1](winnow, query_hash, query_start,  query_end,  query_winnow_start,  query_winnow_end,ref_hash,  ref_start,  ref_end,  ref_winnow_start,  ref_winnow_end, same_genome)
		if (not extended):
			break
	return Hit(query_hash.seq, query_start, query_end, ref_hash.seq, ref_start, ref_end, winnow.jaccard(), "", "OK")


	
	

	
	
	

def search_in_reference_interval( query_start: int, query_winnow_start:int,  query_winnow_end:int, query_hash: Index,  ref_hash: Index,tree: Tree, same_genome: bool,  init_len: int,  allow_extend: bool,  report_fails:bool, winnow: SlidingMap,  t_start: int,  t_end: int, s:Search) ->list[Hit]:
	assert(t_start <= t_end)
	assert(t_start >= 0)
	assert(winnow.query_size > 0)

	TOTAL_ATTEMPTED = 0
	JACCARD_FAILED = 0
	INTERVAL_FAILED=0
	TOTAL_ATTEMPTED+=1

	ref_start = t_start
	ref_end = min(t_start + init_len, len(ref_hash.seq.seq)) # winnow is W(query) ; extend it to W(query) | W(ref)
	ref_winnow_start = ref_hash.find_minimizers(ref_start)
	# print f'r w s{ref_winnow_start}'

	assert(ref_winnow_start < len(ref_hash.minimizers))

	ref_winnow_end = ref_winnow_start
	while (ref_winnow_end < len(ref_hash.minimizers) and ref_hash.minimizers[ref_winnow_end].loc < ref_end):
		winnow.add_to_reference(ref_hash.minimizers[ref_winnow_end].hash)
		ref_winnow_end+=1
	# this part (next while loop) can be optimized
	# Roll until we find best inital match

	best_winnow = SlidingMap(winnow)
	best_ref_start = ref_start
	best_ref_end = ref_end

	best_ref_winnow_start = ref_winnow_start
	best_ref_winnow_end = ref_winnow_end

	while (ref_start < t_end and ref_end < len(ref_hash.seq.seq)):
		if (ref_winnow_start < len(ref_hash.minimizers) and ref_hash.minimizers[ref_winnow_start].loc < ref_start + 1) :
			winnow.remove_from_reference(ref_hash.minimizers[ref_winnow_start].hash)
			ref_winnow_start+=1
		if (ref_winnow_end < len(ref_hash.minimizers) and ref_hash.minimizers[ref_winnow_end].loc == ref_end):
			winnow.add_to_reference(ref_hash.minimizers[ref_winnow_end].hash)
			ref_winnow_end+=1
		if (winnow.jaccard() > best_winnow.jaccard()):
			best_ref_start = ref_start
			best_ref_end = ref_end
			best_ref_winnow_start = ref_winnow_start
			best_ref_winnow_end = ref_winnow_end
			best_winnow = winnow
		ref_start+=1
		ref_end+=1
		if (ref_end == len(ref_hash.seq.seq)):
			break
	
	hits = list[Hit]()
	if (best_winnow.jaccard() < 0):
		JACCARD_FAILED+=1
		if (report_fails):
			hits.append(Hit(query_hash.seq, query_start, query_start + init_len, ref_hash.seq, best_ref_start, best_ref_end, best_winnow.jaccard(),"", "")) #printing funtion used: fmt::format("jaccard: {} < {}"
	elif (allow_extend):
		if (not is_overlap(tree, query_start, query_start + init_len, best_ref_start, best_ref_end,s)):
			f = filter(query_hash.seq.seq, query_start, query_start + init_len, ref_hash.seq.seq, ref_start, ref_end)
			if (not f[0]):
				if (report_fails):
					hits.append(Hit(query_hash.seq, query_start, query_start + init_len, ref_hash.seq, ref_start, ref_end, 0, "", "" ))
			else:
				h = extend1(best_winnow,query_hash, query_start, query_start + init_len, query_winnow_start, query_winnow_end,ref_hash, best_ref_start, best_ref_end, best_ref_winnow_start, best_ref_winnow_end, same_genome,s)
				f = filter(query_hash.seq.seq, h.query_start, h.query_end, ref_hash.seq.seq, h.ref_start, h.ref_end)
				if (not f[0]):
					if (report_fails):
						h.comment = f[1]
						hits.append(h)
				else:
					hits.append(h)
					a = Interval(h.query_start, h.query_end)
					b = Interval(h.ref_start, h.ref_end)
					tree.insert1(a,b)
		else:
			INTERVAL_FAILED+=1
	else:
		f = filter(query_hash.seq.seq, query_start, query_start + init_len, ref_hash.seq.seq, best_ref_start, best_ref_end)
		if (f[0] or report_fails):
			hits.append(Hit(query_hash.seq, query_start, query_start + init_len,ref_hash.seq, best_ref_start, best_ref_end, best_winnow.jaccard(), "", ""))

	return hits


def getSlidingMap(i:int) -> SlidingMap:
	return SlidingMap(i)

class pair:
	first: int
	second: int

	def __init__(self: pair, i: int,j:int):
		self.first = i
		self.second = j
	def __getitem__(self: pair, num: int) -> int:
		assert(num<3)
		if num == 0:
			return self.first
		else:
			return self.second
	def __setitem__(self: pair, num: int, value: int):
		assert(num<3)
		if num == 0:
			self.first = value
		else:
			self.second = value

#qi, query_hash, ref_hash, tree, is_same_genome,Search2.MIN_READ_SIZE, True, False)

def search(query_winnow_start: int, query_hash: Index, ref_hash: Index, tree: Tree, same_genome: bool,init_len: int, allow_extend:bool, report_fails:bool,s:Search) -> list[Hit]:
	
	internal = Internal()
	hashG = HashGlobal()
	
	l = list[Hit]()
	
	
	if (query_winnow_start >= len(query_hash.minimizers)):
		return l
	
	query_start = query_hash.minimizers[query_winnow_start].loc
	
	if (query_start + init_len > len(query_hash.seq.seq)):
		return l
	assert(query_hash.kmer_size == ref_hash.kmer_size)

	init_winnow=SlidingMap(query_hash.kmer_size,s)
	
	candidates_prel = set[int]()
	query_winnow_end2 = query_winnow_start
	# print f'Mimizer list length: {len(query_hash.minimizers)}\n'
	# print ref_hash.index
	for query_winnow_end in range (query_winnow_start, len(query_hash.minimizers)):
		# print "oke"
		if not (query_hash.minimizers[query_winnow_end].loc - query_start <= init_len):
			break
		query_winnow_end2+=1
		# print "oke"
		h = query_hash.minimizers[query_winnow_end].hash
		
		init_winnow.add_to_query(h)
		if (internal.DoUppercaseSeeds and h.status != h.statuses.index("HAS_UPPERCASE")):
			continue
		
		
		pf = tree.find(query_hash.minimizers[query_winnow_end].loc, False)
		ptr = list[int]()
		
		if h.hash in ref_hash.index:
		# print h.hash
			ptr = ref_hash.index[h.hash]
		# if len(ptr)>0:
		# 	print len(ptr)
		if (len(ptr) == 0 or len(ptr) >= ref_hash.threshold):
			continue
		
		else:
			for pos in ptr:
				if (not same_genome or pos >= query_start + init_len):
					# print f'POSITIN 1: {pos}'
					if (len(pf) == 0 or len(tree.findPairsWithinTheRefference(pos,pf) ) == 0 ):
						candidates_prel.add(pos)
	# print f'Cand size:{len(candidates_prel)}'
	if ( not init_winnow.query_size):
		return  list[Hit]()
	T = list[pair]()
	candidates = list[int]()
	for i in sorted(candidates_prel):
		candidates.append(i)
		# print f'Is: {i}\n'
	# i = 0
	for i in range(0, int(len(candidates) - init_winnow.limit+0.5) ):
		j = int(i + (init_winnow.limit - 1))
		if (candidates[j] - candidates[i] <= init_len):
			x = max(0, candidates[j] - init_len + 1)
			y = candidates[i] + 1
			if (len(T)>0 and x < T[-1][1]):
				T[-1][1] = max(T[-1][1], y)
			else:
				T.append(pair(x, y))
	hits = list[Hit]()
	# print f'Tsize:{len(T)}'
	for t in T:
		if (same_genome):
			t[0] = max(t[0], query_start + init_len)
		if (t[0] > t[1]):
			continue
		# print f'ALL PARAMS: {query_start}\t{query_winnow_start}\t{query_winnow_end2}\t{init_len}\t{allow_extend}\t{t[0]}\t{t[1]}\n'
		h = search_in_reference_interval(query_start, query_winnow_start, query_winnow_end2,query_hash, ref_hash, tree, same_genome, init_len,allow_extend, report_fails, init_winnow, t[0], t[1],s)
		# print f'H size {len(h)}'
		for hh in h:
			hits.append(hh)
	# remove the interval from tree!
	# tree -= Interval(0, query_start - Globals::Search::MIN_READ_SIZE)
	return parse_hits(hits)
	