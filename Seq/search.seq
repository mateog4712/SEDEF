from hit import *
from Tree import *
from hash import *
from sliding import *
from hit import *

def is_overlap(tree:Tree,pf_pos,pf_end, pfp_pos,pfp_end) -> bool:
	assert(pf_pos <= pf_end)
	assert(pfp_pos <= pfp_end)
	i1  = set(Interval(pf_pos,pf_end) + Interval(pfp_pos,pfp_end))
	# for it in i1:
	#     sA = 
	if len(i1) > 0:
		return True
	return False

def parse_hits(hits: list[Hit]):
	hits_real = list[Hit]()
	for (h in hits):
		add = True
		for (ph in hits):
			if(&h  != &ph ):
				if (h.ref_start >= ph.ref_start and h.ref_end <= ph.ref_end and h.query_start >= ph.query_start and h.query_end <= ph.query_end):
					add = False
					break
		if (add):
			hits_real.append(h)
	return hits_real




def search_in_reference_interval( query_start: int, query_winnow_start:int,  query_winnow_end:int, query_xhash: Index,  ref_hash: Index,tree: Tree, same_genome: bool,  init_len: int,  allow_extend: bool,  report_fails:bool, winnow: SlidingMap,  t_start: int,  t_end: int) ->list[Hit]:
	assert(t_start <= t_end)
	assert(t_start >= 0)
	assert(winnow.query_size > 0)

	TOTAL_ATTEMPTED+=1

	ref_start = t_start
	ref_end = min(t_start + init_len, len(ref_hash.seq.seq)) # winnow is W(query) ; extend it to W(query) | W(ref)
	ref_winnow_start = ref_hash.find_minimizers(ref_start)
	assert(ref_winnow_start < len(ref_hash.minimizers))
	ref_winnow_end = ref_winnow_start
	while (ref_winnow_end < len(ref_hash.minimizers) and ref_hash.minimizers[ref_winnow_end].loc < ref_end):
		winnow.add_to_reference(ref_hash.minimizers[ref_winnow_end].hash)
		ref_winnow_end+=1
	# this part (next while loop) can be optimized
	# Roll until we find best inital match

	SlidingMap best_winnow(winnow)
	best_ref_start = ref_start
	best_ref_end = ref_end

	best_ref_winnow_start = ref_winnow_start
	best_ref_winnow_end = ref_winnow_end
	while (ref_start < t_end and ref_end < len(ref_hash.seq.seq)):
		if (ref_winnow_start < len(ref_hash.minimizers) and ref_hash.minimizers[ref_winnow_start].loc < ref_start + 1) :
			winnow.remove_from_reference(ref_hash.minimizers[ref_winnow_start].hash)
			ref_winnow_start+=1
		if (ref_winnow_end < len(ref_hash.minimizers) and ref_hash.minimizers[ref_winnow_end].loc == ref_end):
			winnow.add_to_reference(ref_hash.minimizers[ref_winnow_end].hash)
			ref_winnow_end+=1
		if (winnow.jaccard() > best_winnow.jaccard()):
			best_ref_start = ref_start
			best_ref_end = ref_end
			best_ref_winnow_start = ref_winnow_start
			best_ref_winnow_end = ref_winnow_end
			best_winnow = winnow
		ref_start+=1
		ref_end+=1
		if (ref_end == len(ref_hash.seq.seq)):
			break
	
	hits = list[Hit]()
	if (best_winnow.jaccard() < 0):
		JACCARD_FAILED+=1
		if (report_fails) hits.push_back({query_hash.seq, query_start, query_start + init_len, ref_hash.seq, best_ref_start, best_ref_end, best_winnow.jaccard(),"", ""}) #printing funtion used: fmt::format("jaccard: {} < {}"
	elif (allow_extend):
		if (not is_overlap(tree, query_start, query_start + init_len, best_ref_start, best_ref_end)):
			f = filter(query_hash.seq.seq, query_start, query_start + init_len, ref_hash.seq.seq, ref_start, ref_end)
			if (not f[0]):
				if (report_fails):
					hits.push_back(Hit(query_hash.seq, query_start, query_start + init_len, ref_hash.seq, ref_start, ref_end, 0, "", "" ))
			else:
				h = extend(best_winnow,query_hash, query_start, query_start + init_len, query_winnow_start, query_winnow_end,ref_hash, best_ref_start, best_ref_end, best_ref_winnow_start, best_ref_winnow_end, same_genome)
				f = filter(query_hash.seq.seq, h.query_start, h.query_end, ref_hash.seq.seq, h.ref_start, h.ref_end)
				if (not f[0]):
					if (report_fails):
						h.comment = f[1]
						hits.append(h)
				else:
					hits.push_back(h)
					a = Interval(h.query_start, h.query_end)
					b = Interval(h.ref_start, h.ref_end)
					tree += make_pair(a, Subtree({b, {make_pair(a, b)}}))
		else:
			INTERVAL_FAILED+=1
	else:
		f = filter(query_hash.seq.seq, query_start, query_start + init_len, ref_hash.seq.seq, best_ref_start, best_ref_end)
		if (f[0] or report_fails):
			hits.push_back(Hits(query_hash.seq, query_start, query_start + init_len,ref_hash.seq, best_ref_start, best_ref_end, best_winnow.jaccard(), "", ""))

	return hits








def search(query_winnow_start: int, query_hash: Index, ref_hash: Index, tree: Tree, same_genome: bool,init_len: int, allow_extend:bool, report_fails:bool) -> list[Hit]:
	internal = Internal()
	hashG = HashGlobal()
	
	l = list[Hit]()
	

	if (query_winnow_start >= len(query_hash.minimizers)):
		return l
	query_start = query_hash.minimizers[query_winnow_start].loc
	if (query_start + init_len > len(query_hash.seq.seq)):
		return l
	assert(query_hash.kmer_size == ref_hash.kmer_size)
	init_winnow = SlidingMap(query_hash.kmer_size)
	candidates_prel = set[int]()
	query_winnow_end = query_winnow_start
	while( query_winnow_end < len(query_hash.minimizers) and query_hash.minimizers[query_winnow_end].loc - query_start <= init_len):
		h = query_hash.minimizers[query_winnow_end].hash
		init_winnow.add_to_query(h)
		if (internal.DoUppercaseSeeds and h.status != hashG.statuses.index("HAS_UPPERCASE")):
			continue
		pf = tree.find(query_hash.minimizers[query_winnow_end].loc, False)
		prt = None
		if h in ref_hash.index:
			ptr = ref_hash.index[h]
		if (not ptr or len(ptr) >= ref_hash.threshold):
			continue
		else:
			for i in prt:
				if (not same_genome or pos >= query_start + init_len):
					if (len(pf) > 0 or len(tree.find(pos,True) ) > 0 ):
						# need to check if 2 intervals correspond to one sequence (ref and query)
						candidates_prel.insert(pos)
		query_winnow_end+=1


	if ( not init_winnow.query_size):
		return  list[Hit]()
	T = list[tuple[int,int]]()
	candidates = list[int]()
	for i in candidates_prel:
		candidates.append(i)
	i = 0
	while (i <= len(candidates) - init_winnow.limit):
		j = i + (init_winnow.limit - 1)
		if (candidates[j] - candidates[i] <= init_len):
			x = max(0, candidates[j] - init_len + 1)
			y = candidates[i] + 1
			if (len(T) and x < T[-1][1]):
				T[-1][1] = max(T[-1][1], y)
			else:
				T.append({x, y})
			
		
		i+=1
	hits = list[Hit]()
	
	for t in T:
		if (same_genome):
			t[0] = max(t[0], query_start + init_len)
		if (t[0] > t[1]):
			continue
		h = search_in_reference_interval(query_start, query_winnow_start, query_winnow_end,query_hash, ref_hash, tree, same_genome, init_len,allow_extend, report_fails, init_winnow, t[0], t[1])
		for (hh in h):
			hits.push_back(hh)
	# remove the interval from tree!
	# tree -= Interval(0, query_start - Globals::Search::MIN_READ_SIZE)
	return parse_hits(hits)
	