from hash import *
from avl import *
from util import *

def lower_bound(d:  dict[Hash, str],m: Hash):
    k = list[Hash]()
    for i in d:
        if i>=m:
            k.append(i)

    return k.sort()

class SlidingMap:
    storage: AVL[Hash, str]
    boundary: AVLNode[Hash,str]

    # typename std::map<Hash, char>::iterator boundary
    query_size: int
    intersection:int
    limit: float
    kmer_size:int

    estimate_memoize: dict[int, int]

    def __init__(self:SlidingMap,kmer_size:int):
        self.kmer_size=kmer_size
        self.query_size=0
        self.intersection = 0
        self.limit = 0.0
        self.storage = AVL[Hash, str]()
        self.estimate_memoize =  dict[int, int]()
        self.boundary =  None # self.storage.find_max()
    
    def jaccard(self:SlidingMap):
        if (self.intersection >= self.limit):
            return self.intersection
        else:
            return self.intersection - self.limit
    
    def add(self:SlidingMap, h: Hash, BIT: int, FULL:int):
        it = self.storage.lower_bound(h)
        inserted = False
        if it and it.key == h:
            if (it.value & BIT):
                return False
            it.value  |= BIT
        else:
            it = self.storage.insert(h,BIT)
            inserted = True

        if (self.boundary and self.query_size and it.key < self.boundary.key):
            self.intersection += (it.value == FULL)
            if (inserted):
                self.intersection -= (self.boundary.value == FULL)
                # assert(boundary != storage.begin()); // |S| >= 1!
                self.boundary = self.boundary.next_smaller() #should go left?

        return True
    def remove(self:SlidingMap,h:Hash, BIT: int, FULL: int):
        it = self.storage.lower_bound(h)
        if (it.key != h or not(it.value & BIT)):
            return False
        if (self.query_size and it.key <= self.boundary.key):
            self.intersection -= (it.value == FULL)
            if (it.value == BIT):
                self.boundary = self.boundary.next_bigger()
                if (self.boundary):
                    self.intersection += (self.boundary.value == FULL)
        if (it.value == BIT):
            assert(it != self.boundary)
            del self.sorage[it.key]
        else:
            it.value &= ~BIT
        return True
    def add_to_query(self: SlidingMap,h:Hash):
        if (not self.add(h, 1)):
            return
        self.query_size+=1
        self.limit = self.relaxed_jaccard_estimate(self.query_size, self.kmer_size, self.estimate_memoize)
        if (not self.boundary):
            self.boundary = self.storage.find_min()
        else:
            self.boundary = self.boundary.next_bigger()
        self.intersection += (self.boundary.value == 3)
    def remove_from_query(self: SlidingMap,h:Hash):
        if (not self.remove(h, 1)):
            return
        self.query_size_=1
        self.limit = relaxed_jaccard_estimate(self.query_size, self.kmer_size, self.estimate_memoize)
        if (not self.boundary):
            self.intersection -= (self.boundary.value == 3)
        if (self.boundary == self.storage.find_min()):
            self.boundary = self.storage.find_max()
        else:
            self.boundary = self.boundary.next_smaller()
    def add_to_reference(self: SlidingMap,h:Hash):
        if (h.status != h.statuses.index("HAS_N")):
            self.add(h, 2)
    def remove_from_reference(self: SlidingMap,h:Hash):
        if (h.status != h.statuses.index("HAS_N")):
            self.remove(h, 2)


        









