from hash import *
from avl import *
from util import *
from globals import *

def lower_bound(d:  dict[Hash, str],m: Hash):
    k = list[Hash]()
    for i in d:
        if i>=m:
            k.append(i)

    return k.sort()

class SlidingMap:
    storage: AVL[Hash, int]
    boundary: AVLNode[Hash,int]

    # typename std::map<Hash, char>::iterator boundary
    query_size: int
    intersection:int
    limit: float
    kmer_size:int

    estimate_memoize: dict[int, int]
    searchGlob: Search

    def __init__(self:SlidingMap,kmer_size:int, s: Search):
        self.kmer_size=kmer_size
        self.query_size=0
        self.intersection = 0
        self.limit = 0.0
        self.storage = AVL[Hash, int]()
        self.estimate_memoize =  dict[int, int]()
        self.boundary =  self.storage.find_max()
        self.searchGlob = s
    
    def __init__(self:SlidingMap,other: SlidingMap):
        self.kmer_size=other.kmer_size
        self.query_size=other.query_size
        self.intersection = other.intersection
        self.limit = other.limit
        self.storage = other.storage
        self.estimate_memoize =  dict[int, int]()

        self.boundary =  other.boundary # self.storage.find_max()
        self.searchGlob = other.searchGlob
    
    def jaccard(self:SlidingMap):
        if (self.intersection >= self.limit):
            return self.intersection
        else:
            return int(self.intersection - self.limit)
    
    def add(self:SlidingMap, h: Hash, BIT: int):#, FULL: int):
        FULL = 3
        it = self.storage.lower_bound(h)
        inserted = False
        if it and it.key == h:
            if (it.value & BIT):
                return False
            it.value  |= BIT
        else:
            it = self.storage.insert(h,BIT)
            inserted = True

        if (self.boundary and self.query_size and it.key < self.boundary.key):
            self.intersection += int(it.value == FULL)
            if (inserted):
                self.intersection -= int(self.boundary.value == FULL)
                # assert(boundary != storage.begin()); // |S| >= 1!
                self.boundary = self.boundary.next_smaller() #should go left?

        return True
    def remove(self:SlidingMap,h:Hash, BIT: int):#, FULL: int
        FULL = 3
        it = self.storage.lower_bound(h)
        if (it.key != h or not(it.value & BIT)):
            return False
        if (self.query_size and it.key <= self.boundary.key):
            self.intersection -= int(it.value == FULL)
            if (it.value == BIT):
                self.boundary = self.boundary.next_larger()
                if (self.boundary):
                    self.intersection += int(self.boundary.value == FULL)
        if (it.value == BIT):
            assert(not it is self.boundary)
            del self.storage[it.key]
        else:
            it.value &= ~BIT
        return True
    def add_to_query(self: SlidingMap,h:Hash):
        if (not self.add(h, 1)):
            return
        self.query_size+=1
        self.limit = float(relaxed_jaccard_estimate(self.query_size, self.kmer_size, self.estimate_memoize,self.searchGlob))
        if (not self.boundary):
            self.boundary = self.storage.find_min()
        else:
            self.boundary = self.boundary.next_larger()
        self.intersection += int(self.boundary.value == 3)
    def remove_from_query(self: SlidingMap,h:Hash):
        if (not self.remove(h, 1)):
            return
        self.query_size=1
        self.limit = relaxed_jaccard_estimate(self.query_size, self.kmer_size, self.estimate_memoize,self.searchGlob)
        if (not self.boundary):
            self.intersection -= int(self.boundary.value == 3)
        if (self.boundary is self.storage.find_min()):
            self.boundary = self.storage.find_max()
        else:
            self.boundary = self.boundary.next_smaller()
    def add_to_reference(self: SlidingMap,h:Hash):
        if (h.status != h.statuses.index("HAS_N")):
            self.add(h, 2)
    def remove_from_reference(self: SlidingMap,h:Hash):
        if (h.status != h.statuses.index("HAS_N")):
            self.remove(h, 2)


        









