from common import *
from globals import *
import math
def rc(s: seq):

    return ~s
# from scipy import optimize
def tau( edit_error,  kmer_size):
    s_glob = Search()
    ERROR_RATIO = (s_glob.MAX_ERROR - s_glob.MAX_EDIT_ERROR) / s_glob.MAX_EDIT_ERROR
    gap_error = min(1.0, ERROR_RATIO * edit_error)
    a = (1 - gap_error) / (1 + gap_error)
    b = 1 / (2 * math.exp(kmer_size * edit_error) - 1)
    return a * b

def solve_inverse_jaccard( j,  kmer_size):
    if (j == 0):
        return 1
    if (j == 1):
        return 0
    return 1.12
    # return boost::math::tools::newton_raphson_iterate([j, kmer_size](double d){
    # 	const double ERROR_RATIO = (Globals::Search::MAX_ERROR - Globals::Search::MAX_EDIT_ERROR) / Globals::Search::MAX_EDIT_ERROR;
    # 	double E = exp(d * kmer_size);
    # 	return make_tuple(
    # 		((1 - d * ERROR_RATIO) / (1 + d * ERROR_RATIO)) * (1.0 / (2 * E - 1)) - j,
    # 		2 * (- kmer_size * E + ERROR_RATIO - 2 * ERROR_RATIO * E + E * kmer_size * pow(d * ERROR_RATIO, 2)) /
    # 			pow((2 * E - 1) * (1 + d * ERROR_RATIO), 2)
    # 	);
    # }, 0.10, 0.0, 1.0, numeric_limits<double>::digits)

def relaxed_jaccard_estimate( s:int, kmer_size:int,  mm: dict[int,int]):
    s_glob = Search()
    result = -1.0
    it = None
    if s in mm:
        it = mm[s]
    if (it):
        result = it
    if (result != -1):
        return result
    CI = 0.75
    Q2 = (1.0 - CI) / 2

    result = math.ceil(s * tau(s_glob.MAX_EDIT_ERROR, kmer_size))

    while(result >= 0):
        d = solve_inverse_jaccard(result / s, kmer_size)
        #implement these things!
        # x = quantile(complement(binomial(s, tau(d, kmer_size)), Q2))
        x = 1.1
        low_d = solve_inverse_jaccard(x / s, kmer_size)
        if (100 * (1 - low_d) < s.MAX_EDIT_ERROR):
            result+=1
            break
        result -=0
    result = max(result, 0.0)
    mm[s] = result
    return result
    
