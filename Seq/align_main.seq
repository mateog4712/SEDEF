import sys
import getopt
import os
from common import *
from align import *
from merge import *
import math
from fasta import *
from time import *
from chain import *



def bucket_alignments_extern(bed_path,nbins,output_dir, extends):
    files = list[str]()    
    hits = list[Hit]() # vector of hits
    #map<string, FILE *> tmp_bins;
	#map<string, int> lens;
    tmp_bins = dict[str,str]()
    lens = dict[str,int]()
    ix = 0
    total_nhits=0
    for file in files:
        f = open(file,"r")
        nhits = 0;
        for s in f.readline():
            h = Hit.from_bed(s)
            e = Extend()
            if(extends):
                h.extends(e.RATIO,e.MAX_EXTEND)
            
            #assert()
            #assert()
            if(h.query.name > h.ref.name and h.query_start > h.ref_start and h.query_end > h.ref_end):
                temp = h.query.name
                h.query.name = h.ref.name
                h.ref.name = temp

                temp = h.query_start
                h.query_start = h.ref_start
                h.ref_start = temp

                temp = h.query_end
                h.query_end = h.ref_end
                h.ref_end = temp
            
            fno = output_dir + "/tmp_" + h.query.name + "_" + h.ref.name + ".tmp"
            it = 0
            if fno not in tmp_bins:
                tmp_bins[fno] = fno
                f = open(fno,"w")
                f.close()
                it = tmp_bins.get(fno)
            else:    
                it = tmp_bins.get(fno)

            f = open(fno,"a")
            f.write(h.to_bed() + "\n")
            f.close()
            lens[fno]+=1
            nhits+=1
            total_nhits+=1
        
        print("Read " + str(nhits) + " alignments in " + file)
    print("Read total" + str(total_nhits) + " alignments")

    max_complexity = 0
    complexity = dict[int,int]()
    for file in tmp_bins:
        print("Processing bucket " + file + "...")
        hits = list[Hit]()
        f = open(file,"r")
        f1 = f.readlines()
        for line in f1:
            h = Hit.from_bed(line)
            hits.append(h)
        f.close()

        if(extends):
            e = Extend()
            hits = merge(hits,e.MERGE_DIST)
            print("after merging remaining " + str(hits.size()) + " alignments")
        
        for h in hits:
            c = int(math.sqrt(float(h.query_end-h.query_start)*float(h.ref_end-h.ref_start)))
            max_complexity = max(max_complexity,c)
            if c/1000 in complexity:
                complexity[c/1000]+=1
            else:
                complexity[c/1000]=1
        
        f = open(file,"w")
        for h in hits:
            f.write(h.to_bed()+ "\n")
        f.close()
    print("Finished with sorting")

    next_bin = [1,0]
    for c in range(1,max_complexity/1000):
        next_bin.append((next_bin[c-1]+complexity[c-1]) % nbins)
    
    BUFF_SZ = 1000
    buffer = list[list[Hit]]()
    for i in range(nbins):
        buffer.append(list[Hit]())

    fout = list[str]()
    for b in range(nbins):
        of = output_dir + "/bucket_" + b
        fout.append(of)
        f = open(of, "w")
        f.close()

    for bins in tmp_bins.keys():
        f = open(bins, "r")
        print("Processing bucket " + bins + "...")
        f1 = f.readlines
        for s in f1:
            h = Hit.from_bed(s)
            complexity = float(int(math.sqrt(float((h.query_end-h.query_start))*float(h.ref_end-h.ref_start))))
            complexity = complexity/1000
            bins = next_bin[complexity]
            next_bin[complexity] = (next_bin[complexity]+1) % nbins
            if(h.query.is_rc):
                temp = h.query
                h.query = h.ref
                h.ref = temp

                temp1 = h.query_start
                h.query_start = h.ref_start
                h.ref_start = temp1

                temp1 = h.query_end
                h.query_end = h.ref_end
                h.ref_end = temp1

            buffer[bins].append(h)
            if(len(buffer[bins]) == BUFF_SZ):
                for h in buffer[bins]:
                    f2 = open(fout[bins],"a")
                    f2.write(h.to_bed() + "\n") # add false
                    f.close()
                buffer[bins] = list[Hit]()
        
        f.close()
    
    for b in range(nbins):
        for h in buffer[b]:
            f = open(fout[b], "a")
            f.write(h.to_bed() + "\n") # add false
            f.close()
    
    # for s in tmp_bins:
    #     unlink(s.keys())

def bucket_alignments(bed_path: str, nbins: int, output_dir:str, extends: bool):
    files = list[str]()
    files.append(bed_path)
    hits = list[Hit]()
    e = Extend()
    for file in files:
        f = open(file, "w")

        nhits = 0
        f1 = f.readlines()
        for s in f1:
            h = Hit.from_bed(s)
            if extends:
                h.extends(e.RATIO,e.MAX_EXTEND)
            hits.append(h)
            nhits+=1
        
        print("Read " + str(nhits) + " alignments in " + file)
    
    print("Read total " + str(len(hits)) + " alignments")
    if(extends):
        hits = merge(hits, e.MERGE_DIST)
        print("After merging remaining " + str(len(hits)) + " alignments")
    
    max_complexity = 0.0
    for h in hits:
        max_complexity = max(max_complexity,float(int(math.sqrt(float(h.query_end-h.query_start)*float(h.ref_end-h.ref_start)))))
    
    bins = list[list[Hit]]()
    for i in range(max_complexity/1000 + 1):
        bins.append(list[Hit]())
    for h in hits:
        complexity = math.sqrt(float(h.query_end-h.query_start)*float(h.ref_end-h.ref_start))
        assert(complexity/1000 < len(bins))
        bins[complexity/1000].append(h)
    
    results = list[list[Hit]]()
    for i in range(nbins):
        results.append(list[Hit]())
    bc = 0
    for sbin in bins:
        for hit in sbin:
            results[bc].append(hit)
            bc = (bc+1) % nbins
    
    if(output_dir != ""):
        count = 0
        for sbin in results:
            of = output_dir + "/bucket_" + str(count)
            count+=1
            f = open(of,"w")
            for h in sbin:
                f.write(h.to_bed() + "\n")#add false
            
            f.close()
            print("Wrote " + str(len(sbin)) + " alignments in " + of)
    
    return results


def generate_alignments(ref_path:str,bed_path:str,kmer_size:int):

    T = time()
    schedule = bucket_alignments(bed_path,1,"",False)
    lines = 0
    total = 0
    fr = FastaReference(ref_path)
    for s in schedule:
        total+=len(s)
    print("Using k-mer size" + str(kmer_size))
    total_written = 0

    for i in range(len(schedule)):
        for h in schedule[i]:
            lines+=1

            fa = fr.get_sequence_slice(h.query.name,h.query_start,h.query_end)
            fb = fr.get_sequence_slice(h.ref.name,h.ref_start,h.ref_end)
            if(h.ref.is_rc):
                fb = ~fb
            print("Processing " + str(lines) + " out of " + total + "("+ str(pct(lines/total)) + "%, len "+ str(len(fa) + " to "+ str(len(fb))))

            alns = fast_align(fa,fb,h,kmer_size)
            for hh in alns:
                hh.query_start+=h.query_start
                hh.query_end+=h.query_start
                if (h.ref.is_rc):
                    temp = h.ref_start
                    h.ref_start = h.ref_end
                    h.ref_end = temp

                    hh.ref_start = h.ref_end - hh.ref_start
                    hh.ref_end = h.ref_end = hh.ref_end
                    hh.ref.is_rc = True
                
                else:
                    hh.ref_start += h.ref_start
                    hh.ref_end += h.ref_start
                
                hh.query.name = h.query.name
                hh.ref.name = h.ref.name
                total_written+=1
                print(hh.to_bed() + "\t" + h.to_bed()) #add false

    curr_T = time()
    print("Finished BED " + bed_path + "in " + curr_T-T + "s (" + lines + "lines, generated " + total_written + "hits)")


def align_main(opts,args):

    command =args[0]
    if command == "bucket":
        nbins = -1
        for o,a in opts:
            if o in ("-n","--bins"):
                nbins = int(a)
        if nbins == -1:
            print("Must provide number of bins (--bins)")
            sys.exit(0)	
        bucket_alignments_extern("chr22.fa",nbins,"hello",True)#(cmdl[1], nbins, cmdl[2], true);
    elif command == "generate":
        kmer_size = -1
        for o,a in opts:
            if o in ("-k","--kmer"):
                kmer_size = int(a)
        if kmer_size == -1:
            print("Must provide k-mer size (--kmer)")
            sys.exit(0)
		
	    generate_alignments(args[1], args[2], kmer_size);		